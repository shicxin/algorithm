# 动态规划

动态规划是一种求解复杂问题的方法，它通过把原问题分解为相对简单的子问题，然后利用子问题的解来构造原问题的解。动态规划常常适用于有重叠子问题和最优子结构性质的问题，比如背包问题，最短路径问题，石子合并问题等。

动态规划的基本步骤是：

-   划分阶段：按照问题的特征，把问题分为若干个阶段，每个阶段对应一个决策。
-   确定状态和状态变量：把问题发展到各个阶段时所处的各种客观情况用不同的状态表示出来。
-   确定决策并写出状态转移方程：根据相邻两个阶段的状态之间的关系，找出从前一阶段转化到后一阶段的决策方法，以及这些决策导致的状态变化。
-   寻找边界条件：确定初始状态和结束状态，以及递推终止的条件。

动态规划的核心思想是记忆化搜索，即把已经计算过的子问题的解保存起来，避免重复计算。动态规划可以从自顶向下或者自底向上进行求解，通常使用数组或者哈希表来存储子问题的解.

------

简单来说对于动态规划问题，主要有**五个步骤**：

1.   确定`dp[]`以及下标的含义
2.   确定递推公式
3.   `dp[]`如何初始化
4.   确定遍历顺序
5.   举例推导`dp[]`数组

如果在写题过程中Find BUG，最简单的还是打印dp数组，看看打印过程与自己的思路那里不同。

发出这样的问题之前，其实可以⾃⼰先思考这三个问题：

-   这道题⽬我举例推导状态转移公式了么？

-   我打印dp数组的⽇志了么？

-   打印出来了dp数组和我想的⼀样么？

如果这灵魂三问⾃⼰都做到了，基本上这道题⽬也就解决了，或者更清晰的知道⾃⼰究竟是哪⼀点不明⽩，是状态转移不明⽩，还是实现代码不知道该怎么写，还是不理解遍历dp数组的顺序。

-------

## **基础题目目录**(文内连接)

1.   [斐波那契数](#斐波那契数)
1.   [爬楼梯](#爬楼梯)
1.   [使⽤最⼩花费爬楼梯](#使⽤最⼩花费爬楼梯[)
1.   [不同路径](#不同路径)



### [斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

>   斐波那契数，通常⽤ F(n) 表⽰，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后⾯的每⼀项数字都是前⾯两项数字的和。也就是：
>
>   F(0) = 0，F(1) = 1
>
>   F(n) = F(n - 1) + F(n - 2)，其中 n > 1
>
>   给你n ，请计算 F(n) 。
>
>   示例 1：
>
>   >   输入：n = 2
>   >
>   >   输出：1
>   >
>   >   解释：F(2) = F(1) + F(0) = 1 + 0 = 1
>
>   示例 2：
>
>   >   输入：n = 3
>   >
>   >   输出：2
>   >
>   >   解释：F(3) = F(2) + F(1) = 1 + 1 = 2
>
>   示例 3：
>
>   >   输入：n = 4
>   >
>   >   输出：3
>   >
>   >   解释：F(4) = F(3) + F(2) = 2 + 1 = 3
>
>   **提示：0 <= n <= 30**

#### **思路：**

这是一道简单题，可以用数组轻松过，但是我们可以使用这道题了解一下基础的动态规划

按照动态规划的流程来说，我们需要使用一个dp数组来维护递归的结果

 1.    确定`dp[]`以及下标的含义

       `dp[i]`的定义为：第`i`个斐波那契的数值

 2.    确定递推公式

       `dp[i] = dp[i - 1] + dp[i - 2]`

 3.    `dp[]`初始化

       `dp[0] = 0, dp[1] = 1`

 4.    确定遍历顺序

       从递推公式来看，递推的过程一定是从前向后的

 5.    举例递推过程中数组的内容

       按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导⼀下，当N为10的时候，

       `dp[]`数组应该是如下的数列：0 1 1 2 3 5 8 13 21 34 55

#### **实现：**

```c++
class Solution {
public:
    int fib(int n) {
        if(n <= 1) return n;
        vector<int> dp(n + 1);
        dp[0] = 0, dp[1] = 1;
        for(int  i = 2; i <= n; i++)
        {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

```c++
main(void)
{
    int n;
    cin >> n;
    if(n < 2) cout << n << endl;
    else
    {
        int dp[n + 1];
        dp[0] = 0, dp[1] = 1;
        for(int i = 2; i <= n; i++)
        {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        cout << dp[n] << endl;
    }
    return 0;
}
```

#### **总结：**

这道题是非常简单，我们主要通过这道题来学习动态规划的解题过程

### [爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

>假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。
>
>每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？
>
>**示例 1：**
>
>
>>输入：n = 2
>>
>>输出：2
>>
>>解释：有两种方法可以爬到楼顶。
>>
>>-   1 阶 + 1 阶
>>-   2 阶
>
>**示例 2：**
>
>>   输入：n = 3
>>
>>   输出：3
>>
>>   解释：有三种方法可以爬到楼顶。
>>
>>   -   1 阶 + 1 阶 + 1 阶
>>   -   1 阶 + 2 阶
>>   -   2 阶 + 1 阶
>
>**提示：1 <= n <= 45**

#### **思路：**

1.   确定`dp[i]`下标的含义

     到达第`i`个台阶的方法数

2.   确定递推公式

     `dp[i] = dp[i - 1] + dp[i - 2]`

3.   dp数组如何初始化

     最开始在`0`，到第一级台阶有一种办法，到第二种台阶有两种办法

     ` dp[1] = 1, dp[2] = 2`

4.   确定遍历顺序 

     从最低的台阶到最高的台阶

5.   举例推导dp数组

     按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导⼀下，当N为10的时候，

     `dp[]`数组应该是如下的数列：![image-20230610021935637](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230610021935637.png)

#### **实现：**

```c++
class Solution {
public:
    int climbStairs(int n) {
        if(n <= 2) return n;
        vector<int> dp(n + 1);
        dp[1] = 1, dp[2] = 2;
        for(int i = 3; i <= n; i++)
        {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

```c++
main(void)
{
    int n; cin >> n;
    if(n <= 2) cout << n << endl;
    else {
        int dp[n + 1] = {0, 1, 2};
        for(int i = 3; i <= n; i++)
        {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        cout << dp[n] << endl;
    }
    return 0;
}
```

#### **优化：**

通过对代码进行分析，我们每次其实只需要使用三个变量来保存值就够了，所以优化代码如下：

```C++
class Solution {
public:
    int climbStairs(int n) {
        if(n <= 2) return n;
        // vector<int> dp(n + 1);
        // dp[1] = 1, dp[2] = 2;
        // for(int i = 3; i <= n; i++)
        // {
        //     dp[i] = dp[i - 1] + dp[i - 2];
        // }
        int ans = 0, dp1 = 1, dp2 = 2;
        for(int i = 3; i <= n; i++)
        {
            ans = dp1 + dp2;
            dp1 = dp2, dp2 = ans;
        }
        return ans;
    }
};
```

#### **总结：**

不太熟悉C++面向对象的写法，一定要尽快熟悉

### [使⽤最⼩花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)
>   给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
>
>   你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。
>
>   请你计算并返回达到楼梯顶部的最低花费。
>
>    
>
>   示例 1：
>
>   >   输入：cost = [10,15,20]
>   >
>   >   输出：15
>   >
>   >   解释：你将从下标为 1 的台阶开始。
>   >
>   >   -   支付 15 ，向上爬两个台阶，到达楼梯顶部。
>   >       总花费为 15 。
>
>   示例 2：
>
>   >   输入：cost = [1,100,1,1,1,100,1,1,100,1]
>   >
>   >   输出：6
>   >
>   >   解释：你将从下标为 0 的台阶开始。
>   >
>   >   - 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
>   >   - 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
>   >   - 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
>   >   - 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
>   >   - 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
>   >   - 支付 1 ，向上爬一个台阶，到达楼梯顶部。
>   >       总花费为 6 。
>
>   **提示：**
>
>   -   2 <= cost.length <= 1000
>   -   0 <= cost[i] <= 999



#### **思路：**

相较于上一道题，每次爬楼梯加上了代价，我们需要记录爬到最后一层楼梯的最小代价。

我们继续按dp的思路进行分析

1.   确定`dp[]`以及下标的含义

     到达第`i`层的最小代价

2.   确定递推公式

     `dp[i] = min((dp[i - 1] + cost[i]), (dp[i - 2 + const[i]]))`===>`dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]`

3.   `dp[]`如何初始化

     使用cost数组进行初始化

4.   确定遍历顺序

     从第三阶开始，第二阶与第一阶肯定是直接到最划算

5.   举例推导`dp[]`数组

     需要根据输入变化

**注意：这个题目没有描述清楚，cost数组是除去最顶层台阶外每层台阶的代价，在这里卡了半天，由于最后一个台阶没有代价，所以答案就是最后两个台阶的最小值**

#### **实现：**

```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost);
        // if(dp.size() <= 2) return min(dp[dp.size() - 1], dp[dp.size() - 2]);
        // 因为使用cost初始化dp，所以不用检查元素也行
        for(int i = 2; i < dp.size(); i++)
        {
            dp[i] += min(dp[i - 1], dp[i - 2]);
        }
        return min(dp[dp.size() - 1], dp[dp.size() - 2]);
    }
};
```

#### **优化：**

与上题优化方式相同，不贴代码了

#### **总结：**

理解题意很重要，也许有时题意讲到不是那么清楚😥，可以根据样例模拟理解。

### [不同路径]()

>   一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
>
>   机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
>
>   问总共有多少条不同的路径？
>
>   示例一：
>
>   >   ![image-20230610033853483](https://www.shichenxin.top/wp-content/uploads/2023/06/image-20230610033853483.png)
>   >
>   >   输入：m = 3, n = 7
>   >   
>   >   输出：28
>
>   示例 2：
>
>   >
>   >
>   >输入：m = 3, n = 2
>   >
>   >输出：3
>   >
>   >解释：从左上角开始，总共有 3 条路径可以到达右下角。
>   >
>   >- 向右 -> 向下 -> 向下
>   >- 向下 -> 向下 -> 向右
>   >- 向下 -> 向右 -> 向下
>   >
>   
>示例 3：
>   
>>   输入：m = 7, n = 3
>   >   
>   >输出：28
>   
>   示例 4：
>   
>   >输入：m = 3, n = 3
>   >
>   >输出：6
>   
>
>提示：
>   
>-   1 <= m, n <= 100
>   -   题目数据保证答案小于等于 2 * 109



[基础题目目录](#基础题目目录)
